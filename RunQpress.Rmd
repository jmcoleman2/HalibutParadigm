---
title: "Simulation_RegreesionTrees"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
require(QPress)

# Fix order of labels on adjacency plot
# Run once

adjacency.image <-
function (edges, required.groups = c(0), cex.axis = 1) 
{
    pal <- c("#92C5DE", "#FFFFFF", "#F4A582")
    A <- adjacency.matrix(edges, required.groups = required.groups)
    nodes <- node.labels(edges)
    n <- length(nodes)
    lwidth <- max(strwidth(nodes, units = "inches", cex = cex.axis))
    opar <- par(mai = c(0, lwidth + 0.2, lwidth + 0.2, 0) + 0.1)
    image(seq_len(n), seq_len(n), t(A)[, rev(seq_len(n))], axes = F, 
        xlab = "", ylab = "", col = pal)
    axis(2, seq_len(n), rev(nodes), las = 2, cex.axis = cex.axis)
    axis(3, seq_len(n), nodes, las = 2, cex.axis = cex.axis)
    box()
    par(opar)
}

environment(adjacency.image) <- as.environment("package:QPress")
```

```{r Run QPress}
# Load in the community model
  # SaintPaul = Saint Paul
  # Savoonga
  # Amendment80 = Amendment 80 Harvester Fleet
  # UnalaskaDutchHarbor = Unalaska/Dutch Harbor

run_qpress <- function(com) {

digraph = paste("/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Dia Files/", as.character(com), ".dia", sep = "")

edges <- model.dia(digraph)

## Function to add in -1 on the diagonal generate the community matrix

edgesNeg <- enforce.limitation(edges)

assign(paste("adj_mat.", com, sep = ""), adjacency.matrix(edgesNeg,labels = TRUE), envir = .GlobalEnv)

assign(paste("adj_image.", com, sep = ""), adjacency.image(edgesNeg), envir = .GlobalEnv)

# 1. Build a set of stable matricies, 
sim <- system.simulate(n.sims = 1000, edges = edgesNeg, 
  sampler = community.sampler(edgesNeg), validators = NULL) 

```

```{r Simulation output}
# We could add additional validation criteria to filter out matricies that don't reproduce a known system behavior 

# The sim object contains the inverse community matrcies, their corresponding edge weights, and a few other things.... 

# Look at the proportion of stable matrices when drawing edge weights from uniform distributions

assign(paste("prop.", com, sep = ""), sim$stable / sim$total, envir = .GlobalEnv)

# 2. Interactively expore how the nodes respond to different press scenarios

impact.barplot(sim)

# Look at how the community responds when nodes are pressed one at a time.
assign(paste("imptable.", com, sep = ""), impact.table(sim), envir = .GlobalEnv)

imptable <- impact.table(sim)

#Which node perturbations have similar community outcomes?

assign(paste("imp_dist.", com, sep = ""), dist(t(imptable)), envir = .GlobalEnv)
imp_dist <- dist(t(imptable))
assign(paste("imp_dist_plot.", com, sep = ""), plot(hclust(imp_dist), main="Perturbation similarity (Euclidean distance)", hang = -1), envir = .GlobalEnv)

assign(paste("imp_dist2.", com, sep = ""), dist(imptable), envir = .GlobalEnv)
imp_dist2 <- dist(imptable)
assign(paste("imp_dist2_plot.", com, sep = ""), plot(hclust(imp_dist2), main="Node similarity across perturbations (Euclidean distance)", hang = -1), envir = .GlobalEnv)

}
```

```{r}
coms <- data.frame(community = c("SaintPaul", "Savoonga", "Amendment80", "UnalaskaDutchHarbor"))

apply(X = coms, MARGIN = 1, FUN = run_qpress)
```

