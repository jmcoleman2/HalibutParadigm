---
title: "Qualitative Network Modeling in QPress"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

options(figure_counter = TRUE)

```

```{r Fig counter setup}

# http://rmflight.github.io/post/writing-papers-using-r-markdown/


# Create variable that stores number, adds incremental value

incCount <- function(inObj){
    nObj <- length(inObj)
    useNum <- max(inObj) + 1
    inObj <- c(inObj, useNum)
    inObj
}

figCount <- 0
tableCount <- 0

# Insert variable with named number into text

pasteLabel <- function(preText, inObj, objName, insLink=TRUE){
    objNum <- tail(inObj, n = 1)
    
    useText <- paste(preText, objNum, sep=" ")
    if (insLink){
        useText <- paste("[", useText, "](#", objName, ")", sep="")
    }
    useText
}

```

```{r Load libraries}
########################################################################
# All code was originally obtained from  Melbourne-Thomas et al. 2012. #
# Modified by Jon Reum and Jesse Coleman                               #
########################################################################

require(QPress)
require(dplyr)
require(purrr)
require(tidyr)
require(ggplot2)
require(reshape2)
require(ggmap)
```

```{r Modify QPress functions}

# Alternative adjacency image function

adjacency.image2 = function(edges, modelname) {
  ggplot(edges %>% complete(From, nesting(To), fill = list(Type = "Z")), 
            aes(y = rev(To), x = From, fill = Type)) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("#81B8D6", "#EF936F", "808080"), 
                    name = "Interaction", 
                    labels = c("Neg", "Pos", "Zero")) +
  theme_minimal() + 
  labs(y = "", x = paste(modelname)) +
  scale_y_discrete(expand = c(0, 0), labels = rev(levels(edges$From))) +
  scale_x_discrete(position = "top", expand = c(0, 0)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 0), 
        axis.ticks = element_blank())
  
}

environment(adjacency.image2) <- as.environment(".GlobalEnv")

# Heat table function

heatimptable <- function(imptable) {
  ggplot(melt(imptable), aes(Var2, Var1, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradient2(low = "#81B8D6", high = "#EF936F", mid = "808080", 
                         midpoint = 0, limit = c(-1,1), space = "Lab", guide = FALSE) +
    geom_text(aes(Var2, Var1, label = round(value, 2)), color = "black", size = 2) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, size = 8, hjust = 1),
      axis.text.y = element_text(size = 8),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.grid.major = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      axis.ticks = element_blank(),
      legend.justification = c(1, 0),
      legend.position = c(0.6, 0.7),
      legend.direction = "horizontal")
  
}

environment(heatimptable) <- as.environment(".GlobalEnv")


# Utility function

extend.vector <- function(named,nodes,default) {
  if(is.null(names(named)))
    v <- rep(named,length.out=length(nodes))
  else {
    k <- match(names(named),nodes)
    if(any(is.na(k)))
      warning("Unknown nodes:",paste(names(named)[is.na(k)],collapse=" "))
    v <- rep(default,length(nodes))
    v[k] <- named
  }
  v
}

environment(extend.vector) <- as.environment(".GlobalEnv")

# Modify impact.barplot0 to include 'cex.names' argument for adjusting edge label text size.

impact.barplot2 <- function (sim, perturb = 0, monitor = NA, epsilon = 1e-05, main = "", 
    cex.axis = 1, cex.names = 1) 
{
    As <- sim$A
    nodes <- node.labels(sim$edges)
    pal <- c("#92C5DE", "#808080", "#F4A582")
    results <- matrix(0, length(nodes), 3)
    perturb <- extend.vector(perturb, nodes, 0)
    monitor <- extend.vector(monitor, nodes, NA)
    for (i in seq_along(As)) {
        impact <- signum(drop(As[[i]] %*% perturb), epsilon = epsilon)
        if (all(monitor == impact, na.rm = T)) {
            results <- results + outer(impact, -1:1, "==")
        }
    }
    rownames(results) <- nodes
    lwidth <- max(strwidth(nodes, units = "inches", cex = cex.axis))
    opar <- par(mai = c(1, lwidth + 0.2, 0.4, 0.4) + 0.2)
    barplot(t(results), horiz = T, las = 1, border = F, col = pal, 
        xlab = "Simulations", main = main, cex.axis = cex.axis, cex.names = cex.names)
    par(opar)
}

environment(impact.barplot2) <- as.environment(".GlobalEnv")

```


# Methods

## Study Communities

```{r Map, out.width = '1000px', out.height = '800px', eval = FALSE}
# Enter list of communities and lats/longs

cdqs <- read.csv("/Volumes/GoogleDrive/My Drive/GIS/AK/AK_Places/CDQ_Communities_LatLong.csv", header = TRUE)

cdqs[18,c(5,6)] <- c(-164.8435, 62.53281)
cdqs[30,c(5,6)] <- c(-165.1047, 60.52948)

cdqs <- cdqs %>% add_row(X = 999, Community = "Unalaska/Dutch Harbor", CDQ_Group = "Aleutian Pribilof Islands Community Development Association", CDQ_Acro = "APICDA", Longitude = -166.5346, Latitude = 53.87245) %>%
  rename(lat = Latitude, lon = Longitude)

study_coms <- data.frame(Community = c("Mekoryuk", "Saint Paul", "Savoonga", "Unalaska/Dutch Harbor"), lon = c(-166.1872, -170.2782, -170.4834, -166.5346), lat = c(60.38723, 57.12114, 63.68954, 53.87245))

# Tell the mapping function where to center the map
ctr <- data.frame(Longitude = -155, Latitude = 63)

ctr2 <- data.frame(Longitude = mean(study_coms$lon), Latitude = mean(study_coms$lat))

ctr3 <- data.frame(Longitude = mean(cdqs$lon), Latitude = mean(cdqs$lat))

# Get Google Maps terrain map
mapbase <- get_map(location = ctr, maptype = "toner-background", source = "stamen", zoom = 4)

mapbase2 <- get_map(location = ctr2,  maptype = "terrain-background", source = "stamen", zoom = 5)

mapbase3 <- get_map(location = ctr3, maptype = "terrain-background", source = "stamen", zoom = 5)
# Plot the map with markers and labels

cdqmap <-
  ggmap(mapbase3) +
    geom_point(data = cdqs, mapping = aes(x = lon, y = lat, color = CDQ_Group), size = 3) +
    theme_nothing()
cdqmap

ggsave(file="/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Maps/cdqmap.svg", plot = cdqmap)

refmap <-
  ggmap(mapbase) +
  theme_nothing()

refmap

ggsave(file = "/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Maps/refmap.png", plot = refmap)

sc_map <-
  ggmap(mapbase2) +
    geom_point(data = study_coms, mapping = aes(x = lon, y = lat), color = "#000000", size = 2) +
    geom_text(data = study_coms, aes(label = paste("   ", as.character(Community), sep="")), hjust = 0.05) +
    theme_nothing()

sc_map


```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Map of study communities.

# Results

```{r Map QPress over all models, fig.show = 'hide'}

# Create list of path names to Dia models
path <- c("/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Dia Files/")

dia_paths <- list(stpaul = paste(path, "stpaul.dia", sep = ""), 
                  savoonga = paste(path, "savoonga.dia", sep = ""),
                  unalaska = paste(path, "unalaskadutch.dia", sep = ""),
                  am80 = paste(path, "am80.dia", sep = ""),
                  stpaul_l = paste(path, "stpaul_l.dia", sep = ""), 
                  savoonga_l = paste(path, "savoonga_l.dia", sep = ""),
                  unalaska_l = paste(path, "unalaskadutch_l.dia", sep = ""),
                  am80_l = paste(path, "am80_l.dia", sep = "")
                  )

# Convert Dia digraphs to table for use in QPress simulations

edges <- map(dia_paths, model.dia)


# Add self-limitation of each node (i.e., -1 on the diagonal of the community matrix)

edges_lim <- edges %>% map(~ enforce.limitation(.))


# Build adjacency (community) matrices for all models

adj_mats <- edges_lim %>% map(~ adjacency.matrix(labels = TRUE, edges = .))


# Produce plot of adjacency matrices (effect of column node on row node) with light blue for negative and orange for positive interactions.

adj_images <- map2(.x = edges_lim, .y = c("St. Paul", "Savoonga", "Unalaska/Dutch Harbor", "Amendment 80", "St. Paul (linked)", "Savoonga (linked)", "Unalaska/Dutch Harbor (linked)", "Amendment 80 (linked)"), .f = adjacency.image2)

# Run simulations
# Not working...in progress

argslist <-list(
  n.sims <- c(rep(1000, 4)),
  edges <- edges_lim,
  required.groups <- c(rep(c(0))),
  sampler <- community.sampler(edges_lim),
  validators <- c(rep(NULL, 4))
)


# Need pmap for multiple arg lists, and invoke_map for multiple functions taken as arguments
# sims <<- pmap(.l = argslist, .f = system.simulate)
             
# The Old Fashioned way

sims <- list(
  stpaul = system.simulate(n.sims = 1000, edges = edges_lim$stpaul, sampler = community.sampler(edges_lim$stpaul), validators = NULL),
  savoonga = system.simulate(n.sims = 1000, edges = edges_lim$savoonga, sampler = community.sampler(edges_lim$savoonga), validators = NULL),
  unalaska = system.simulate(n.sims = 1000, edges = edges_lim$unalaska, sampler = community.sampler(edges_lim$unalaska), validators = NULL),
  am80 = system.simulate(n.sims = 1000, edges = edges_lim$am80, sampler = community.sampler(edges_lim$am80), validators = NULL),
  stpaul_l = system.simulate(n.sims = 1000, edges = edges_lim$stpaul_l, sampler = community.sampler(edges_lim$stpaul_l), validators = NULL),
  savoonga_l = system.simulate(n.sims = 1000, edges = edges_lim$savoonga_l, sampler = community.sampler(edges_lim$savoonga_l), validators = NULL),
  unalaska_l = system.simulate(n.sims = 1000, edges = edges_lim$unalaska_l, sampler = community.sampler(edges_lim$unalaska_l), validators = NULL),
  am80_l = system.simulate(n.sims = 1000, edges = edges_lim$am80_l, sampler = community.sampler(edges_lim$am80_l), validators = NULL)
)
```


```{r Impact tables}
# Create impact tables for each model; values are positive press perturbation of column node impacts (-1 to 1) on row nodes

imptables <- map(.x = sims, .f = impact.table)

# Create heat maps of impact tables

heatimptables <- map(.x = imptables, .f = heatimptable)


# Which node perturbations have similar community outcomes?

imp_dist_pert <- map(.x = imptables, .f = ~ hclust(dist(t(.))))
# plot() args
# plot(imp_dist_pert$stpaul, main = paste(names(.), "Perturbation similarity", sep = " "), hang = -1))


imp_dist_node <- map(.x = imptables, .f = ~ hclust(dist(.)))
# plot() args
# plot(imp_dist_node$stpaul, main = paste(names(.), "Node similarity across perturbations (Euclidean distance)", sep = " "), hang = -1)


```

# Saint Paul
## Digraph

![](/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Digraphs/SaintPaul.png)  

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Digraph showing relationships (edges) between variables (nodes) for the St. Paul community model.


***
## Community matrix

``` {r out.width = '1000px'} 
adj_images$stpaul
adj_images$stpaul_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Representation of the Saint Paul community matrix in which blue cells indicate a negative effect of column node on row node, and orange indicate a positive effect. Diagonals in blue indicate that each node in the system is assumed to be self-limiting.


***
## Press perturbations

``` {r out.width = '1000px'}
impact.barplot2(sims$stpaul, perturb = c("Halibut abundance" = 1), cex.axis = 1, cex.names = 0.75)
impact.barplot2(sims$stpaul_l, perturb = c("Halibut abundance" = 1), cex.axis = 1, cex.names = 0.75)

```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to an increase in halibut abundance for St. Paul community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


``` {r out.width = '1000px'} 
impact.barplot2(sims$stpaul, perturb = c("Halibut bycatch limits" = -1), cex.axis = 1, cex.names = 0.75)
impact.barplot2(sims$stpaul_l, perturb = c("Halibut bycatch limits" = -1), cex.axis = 1, cex.names = 0.75)

```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to a decrease in halibut bycatch limits for St. Paul community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


***
## Impact table

``` {r out.width = '1000px'} 
heatimptables$stpaul
heatimptables$stpaul_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Mean simulated effect on row variable of positive perturbation of column variable.


***
## Node similarity across perturbations

``` {r out.width = '1000px'} 
plot(imp_dist_node$stpaul, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_node$stpaul_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing node similarity across perturbations (Euclidean distance). The more similarly a pair of nodes responds to a press perturbation of any kind, the closer they will be grouped in the dendrogram.


***
## Perturbation similarity

``` {r out.width = '1000px'} 
plot(imp_dist_pert$stpaul, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_pert$stpaul_l, cex = 0.75, xlab = "", main = "", sub = "")
``` 

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing perturbation similarity (Euclidean distance). The more similarly a pair of nodes affects all other nodes when perturbed (positively?), the closer they will be grouped in the dendrogram. 

***

# Savoonga
## Digraph

![](/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Digraphs/Savoonga.png)

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Digraph showing relationships (edges) between variables (nodes) for the Savoonga community model.


***
## Community matrix

``` {r out.width = '1000px'} 
adj_images$savoonga
adj_images$savoonga_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Representation of the Savoonga community matrix in which blue cells indicate a negative effect of column node on row node, and orange indicate a positive effect. Diagonals in blue indicate that each node in the system is assumed to be self-limiting.


***
## Press perturbations

``` {r out.width = '1000px'}
impact.barplot2(sims$savoonga, perturb = c("Halibut abundance" = 1), cex.axis = 0.5)
impact.barplot2(sims$savoonga_l, perturb = c("Halibut abundance" = 1), cex.axis = 0.5)
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to an increase in halibut abundance for Savoonga community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


``` {r out.width = '1000px'} 
impact.barplot2(sims$savoonga, perturb = c("Halibut bycatch limits" = -1), cex.axis = 0.75)
impact.barplot2(sims$savoonga_l, perturb = c("Halibut bycatch limits" = -1), cex.axis = 0.75)
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to a decrease in halibut bycatch limits for Savoonga community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


***
## Impact table

``` {r out.width = '1000px'} 
heatimptables$savoonga
heatimptables$savoonga_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Mean simulated effect on row variable of positive perturbation of column variable.


***
## Node similarity across perturbations

``` {r out.width = '1000px'} 
plot(imp_dist_node$savoonga, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_node$savoonga_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing node similarity across perturbations (Euclidean distance). The more similarly a pair of nodes responds to a press perturbation of any kind, the closer they will be grouped in the dendrogram.


***
## Perturbation similarity

``` {r out.width = '1000px'} 
plot(imp_dist_pert$savoonga, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_pert$savoonga_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing perturbation similarity (Euclidean distance). The more similarly a pair of nodes affects all other nodes when perturbed (positively?), the closer they will be grouped in the dendrogram. 


# Unalaska/Dutch Harbor
## Digraph

![](/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Digraphs/UnalaskaDutchHarbor.png)

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Digraph showing relationships (edges) between variables (nodes) for the Unalaska/Dutch Harbor community model.


***
## Community matrix

``` {r out.width = '1000px'} 
adj_images$unalaska
adj_images$unalaska_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Representation of the Unalaska/Dutch Harbor community matrix in which blue cells indicate a negative effect of column node on row node, and orange indicate a positive effect. Diagonals in blue indicate that each node in the system is assumed to be self-limiting.


***
## Press perturbations

``` {r out.width = '1000px'}
impact.barplot2(sims$unalaska, perturb = c("Halibut abundance" = 1), cex.axis = 0.5)
impact.barplot2(sims$unalaska_l, perturb = c("Halibut abundance" = 1), cex.axis = 0.5)
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to an increase in halibut abundance for Unalaska/Dutch Harbor community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


``` {r out.width = '1000px'} 
impact.barplot2(sims$unalaska, perturb = c("Halibut bycatch limits" = -1), cex.axis = 0.75)
impact.barplot2(sims$unalaska_l, perturb = c("Halibut bycatch limits" = -1), cex.axis = 0.75)
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to a decrease in halibut bycatch limits for Unalaska/Dutch Harbor community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


***
## Impact table

``` {r out.width = '1000px'} 
heatimptables$unalaska
heatimptables$unalaska_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Mean simulated effect on row variable of positive perturbation of column variable.


***
## Node similarity across perturbations

``` {r out.width = '1000px'} 
plot(imp_dist_node$unalaska, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_node$unalaska_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing node similarity across perturbations (Euclidean distance). The more similarly a pair of nodes responds to a press perturbation of any kind, the closer they will be grouped in the dendrogram.


***
## Perturbation similarity

``` {r out.width = '1000px'} 
plot(imp_dist_pert$unalaska, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_pert$unalaska_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing perturbation similarity (Euclidean distance). The more similarly a pair of nodes affects all other nodes when perturbed (positively?), the closer they will be grouped in the dendrogram. 


# Amendment 80
## Digraph

![](/Volumes/GoogleDrive/My Drive/Halibut Paradigm/Digraphs/Amendment80Fleet.png)

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Digraph showing relationships (edges) between variables (nodes) for the Amendment 80 community model.


***
## Community matrix

``` {r out.width = '1000px'} 
adj_images$am80
adj_images$am80_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Representation of the Amendment 80 community matrix in which blue cells indicate a negative effect of column node on row node, and orange indicate a positive effect. Diagonals in blue indicate that each node in the system is assumed to be self-limiting.


***
## Press perturbations

``` {r out.width = '1000px'}
impact.barplot2(sims$am80, perturb = c("Halibut abundance" = 1), cex.axis = 0.5)
impact.barplot2(sims$am80_l, perturb = c("Halibut abundance" = 1), cex.axis = 0.5)
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to an increase in halibut abundance for Amendment 80 community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


``` {r out.width = '1000px'} 
impact.barplot2(sims$am80, perturb = c("Halibut bycatch limits" = -1), cex.axis = 0.75)
impact.barplot2(sims$am80_l, perturb = c("Halibut bycatch limits" = -1), cex.axis = 0.75)
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Impact barpot of simulated responses to a decrease in halibut bycatch limits for Amendment 80 community model. The proportion of simulated stable (retained) matrices that had a negative response at the node in question is shown in blue, and the proportion of stable matrices in which that node had a positive response is shown in orange.


***
## Impact table

``` {r out.width = '1000px'} 
heatimptables$am80
heatimptables$am80_l
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Mean simulated effect on row variable of positive perturbation of column variable.


***
## Node similarity across perturbations

``` {r out.width = '1000px'} 
plot(imp_dist_node$am80, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_node$am80_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing node similarity across perturbations (Euclidean distance). The more similarly a pair of nodes responds to a press perturbation of any kind, the closer they will be grouped in the dendrogram.


***
## Perturbation similarity

``` {r out.width = '1000px'} 
plot(imp_dist_pert$am80, cex = 0.75, xlab = "", main = "", sub = "")
plot(imp_dist_pert$am80_l, cex = 0.75, xlab = "", main = "", sub = "")
```

`r figCount <- incCount(figCount)`
`r I(pasteLabel("Figure", figCount, "", FALSE))`. Dendrogram showing perturbation similarity (Euclidean distance). The more similarly a pair of nodes affects all other nodes when perturbed (positively?), the closer they will be grouped in the dendrogram. 